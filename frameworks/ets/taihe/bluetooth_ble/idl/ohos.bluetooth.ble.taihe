/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.bluetooth.ble", "ble")

@!sts_inject_into_module("import { BusinessError, AsyncCallback } from '@ohos.base';")
@!sts_inject("""
static { loadLibrary("bluetoothBle_taihe_native.z") }
""")
from ohos.bluetooth.constant use ProfileConnectionState;

struct ScanReport {
    reportType: ScanReportType;
    scanResult: Array<ScanResult>;
}
enum ScanReportType: i32 {
    ON_FOUND = 1,
    ON_LOST = 2
}
struct ScanResult {
    deviceId: String;
    rssi: i32;
    data: @arraybuffer Array<u8>;
    deviceName: String;
    connectable: bool;
}

enum MatchMode: i32 {
    MATCH_MODE_AGGRESSIVE = 1,
    MATCH_MODE_STICKY = 2
}

struct AdvertisingEnableParams {
    advertisingId: i32;
    duration: Optional<i32>;
}

struct DescriptorWriteRequest {
    deviceId: String;
    transId: i32;
    offset: i32;
    isPrepared: bool;
    needRsp: bool;
    value: @arraybuffer Array<u8>;
    descriptorUuid: String;
    characteristicUuid: String;
    serviceUuid: String;
}

struct DescriptorReadRequest {
    deviceId: String;
    transId: i32;
    offset: i32;
    descriptorUuid: String;
    characteristicUuid: String;
    serviceUuid: String;
}

struct AdvertiseSetting {
    interval: Optional<i32>;
    txPower: Optional<i32>;
    connectable: Optional<bool>;
}

struct NotifyCharacteristic {
    serviceUuid: String;
    characteristicUuid: String;
    characteristicValue: @arraybuffer Array<u8>;
    confirm: bool;
}

struct ScanFilter {
    deviceId: Optional<String>;
    name: Optional<String>;
    serviceUuid: Optional<String>;
    serviceUuidMask: Optional<String>;
    serviceSolicitationUuid: Optional<String>;
    serviceSolicitationUuidMask: Optional<String>;
    serviceData: Optional<@arraybuffer Array<u8>>;
    serviceDataMask: Optional<@arraybuffer Array<u8>>;
    manufactureId: Optional<i32>;
    manufactureData: Optional<@arraybuffer Array<u8>>;
    manufactureDataMask: Optional<@arraybuffer Array<u8>>;
}

union ScanFilterNullValue {
    filters: Array<ScanFilter>;
    @null nValue;
}

struct CharacteristicReadRequest {
    deviceId: String;
    transId: i32;
    offset: i32;
    characteristicUuid: String;
    serviceUuid: String;
}

struct CharacteristicWriteRequest {
    deviceId: String;
    transId: i32;
    offset: i32;
    isPrepared: bool;
    needRsp: bool;
    value: @arraybuffer Array<u8>;
    characteristicUuid: String;
    serviceUuid: String;
}

function StopBLEScan(): void;

struct ServerResponse {
    deviceId: String;
    transId: i32;
    status: i32;
    offset: i32;
    value: @arraybuffer Array<u8>;
}

struct ScanOptions {
    interval: Optional<i32>;
    dutyMode: Optional<ScanDuty>;
    matchMode: Optional<MatchMode>;
    phyType: Optional<PhyType>;
    reportMode: Optional<ScanReportMode>;
}

enum ScanDuty: i32 {
    SCAN_MODE_LOW_POWER = 0,
    SCAN_MODE_BALANCED = 1,
    SCAN_MODE_LOW_LATENCY = 2
}

enum PhyType: i32 {
    PHY_LE_1M = 1,
    PHY_LE_ALL_SUPPORTED = 255
}

enum ScanReportMode: i32 {
    NORMAL = 1,
    BATCH = 2,
    FENCE_SENSITIVITY_LOW = 10,
    FENCE_SENSITIVITY_HIGH = 11
}

struct BLECharacteristic {
    serviceUuid: String;
    characteristicUuid: String;
    characteristicValue: @arraybuffer Array<u8>;
    descriptors: Array<BLEDescriptor>;
    properties: Optional<GattProperties>;
    characteristicValueHandle: Optional<i32>;
    permissions: Optional<GattPermissions>;
}

struct AdvertisingStateChangeInfo {
    advertisingId: i32;
    state: AdvertisingState;
}

enum AdvertisingState: i32 {
    STARTED = 1,
    ENABLED = 2,
    DISABLED = 3,
    STOPPED = 4
}

struct BLEDescriptor {
    serviceUuid: String;
    characteristicUuid: String;
    descriptorUuid: String;
    descriptorValue: @arraybuffer Array<u8>;
    descriptorHandle: Optional<i32>;
    permissions: Optional<GattPermissions>;
}

struct GattProperties {
    write: Optional<bool>;
    writeNoResponse: Optional<bool>;
    read: Optional<bool>;
    notify: Optional<bool>;
    indicate: Optional<bool>;
    broadcast: Optional<bool>;
    authenticatedSignedWrite: Optional<bool>;
    extendedProperties: Optional<bool>;
}

enum GattWriteType: i32 {
    WRITE = 1,
    WRITE_NO_RESPONSE = 2
}

struct GattPermissions {
    read: Optional<bool>;
    readEncrypted: Optional<bool>;
    readEncryptedMitm: Optional<bool>;
    write: Optional<bool>;
    writeEncrypted: Optional<bool>;
    writeEncryptedMitm: Optional<bool>;
    writeSigned: Optional<bool>;
    writeSignedMitm: Optional<bool>;
}

function StopAdvertising(): void;

interface GattClientDevice {
    SetBLEMtuSize(mtu: i32): void;
    Connect(): void;
    Disconnect(): void;

    Close(): void;

    @gen_async("getDeviceName")
    @gen_promise("getDeviceName")
    GetDeviceNameSync(): String;
}

function CreateGattClientDevice(deviceId: String): GattClientDevice;

interface GattServer {
    Close(): void;
    AddService(service: GattService): void;
    RemoveService(serviceUuid: String): void;
    SendResponse(serverResponse: ServerResponse): void;
}

function CreateGattServer(): GattServer;

struct AdvertiseData {
    serviceUuids: Array<String>;
    manufactureData: Array<ManufactureData>;
    serviceData: Array<ServiceData>;
    includeDeviceName: Optional<bool>;
    includeTxPower: Optional<bool>;
}

struct AdvertisingParams {
    advertisingSettings: AdvertiseSetting;
    advertisingData: AdvertiseData;
    advertisingResponse: Optional<AdvertiseData>;
    duration: Optional<i32>;
}
struct ManufactureData {
    manufactureId: i32;
    manufactureValue: @arraybuffer Array<u8>;
}

struct ServiceData {
    serviceUuid: String;
    serviceValue: @arraybuffer Array<u8>;
}

struct GattService {
    serviceUuid: String;
    isPrimary: bool;
    characteristics: Array<BLECharacteristic>;
    includeServices: Optional<Array<GattService>>;
}

struct BLEConnectionChangeState {
    deviceId: String;
    state: ProfileConnectionState;
}

struct AdvertisingDisableParams {
    advertisingId: i32;
}

interface BleScanner {
}

function CreateBleScanner(): BleScanner;
function GetConnectedBLEDevices(): Array<String>;
function StartBLEScan(filters: ScanFilterNullValue, options: Optional<ScanOptions>): void;
function StartAdvertising(setting: AdvertiseSetting, advData: AdvertiseData, advResponse: Optional<AdvertiseData>): void;

@!sts_inject("""
native function StartAdvertisingReturnsPromise_inner(advertisingParams: AdvertisingParams): Promise<int>;
export function startAdvertising(advertisingParams: AdvertisingParams): Promise<int> {
    return taskpool.execute((): Promise<int> => {
        console.info("taskpool.execute promise enter");
        return StartAdvertisingReturnsPromise_inner(advertisingParams);
    })
    .then((ret: Any): int => {
        console.info("taskpool.execute promise then, ret: " + ret);
        return ret as int;
    })
};

native function StartAdvertisingWithCallback_inner(advertisingParams: AdvertisingParams, callback: AsyncCallback<int>): void;
export function startAdvertising(advertisingParams: AdvertisingParams, callback: AsyncCallback<int>): void {
    console.info("taskpool.execute callback");
    taskpool.execute((): void => {
        console.info("taskpool.execute callback enter");
        return StartAdvertisingWithCallback_inner(advertisingParams, callback);
    })
};

native function DisableAdvertisingReturnsPromise_inner(advertisingDisableParams: AdvertisingDisableParams): Promise<void>;
export function disableAdvertising(advertisingDisableParams: AdvertisingDisableParams): Promise<void> {
    return taskpool.execute((): Promise<void> => {
        console.info("taskpool.execute promise enter");
        return DisableAdvertisingReturnsPromise_inner(advertisingDisableParams);
    })
    .then((ret: Any): void => {
        console.info("taskpool.execute promise then, ret: " + ret);
    })
};

native function DisableAdvertisingWithCallback_inner(advertisingDisableParams: AdvertisingDisableParams, callback: AsyncCallback<void>): void;
export function disableAdvertising(advertisingDisableParams: AdvertisingDisableParams, callback: AsyncCallback<void>): void {
    taskpool.execute((): void => {
        console.info("taskpool.execute callback enter");
        return DisableAdvertisingWithCallback_inner(advertisingDisableParams, callback);
    })
};

native function EnableAdvertisingReturnsPromise_inner(advertisingEnableParams: AdvertisingEnableParams): Promise<void>;
export function enableAdvertising(advertisingEnableParams: AdvertisingEnableParams): Promise<void> {
    return taskpool.execute((): Promise<void> => {
        console.info("taskpool.execute promise enter");
        return EnableAdvertisingReturnsPromise_inner(advertisingEnableParams);
    })
    .then((ret: Any): void => {
        console.info("taskpool.execute promise then, ret: " + ret);
    })
};

native function EnableAdvertisingWithCallback_inner(advertisingEnableParams: AdvertisingEnableParams, callback: AsyncCallback<void>): void;
export function enableAdvertising(advertisingEnableParams: AdvertisingEnableParams, callback: AsyncCallback<void>): void {
    taskpool.execute((): void => {
        console.info("taskpool.execute callback enter");
        return EnableAdvertisingWithCallback_inner(advertisingEnableParams, callback);
    })
};
""")
